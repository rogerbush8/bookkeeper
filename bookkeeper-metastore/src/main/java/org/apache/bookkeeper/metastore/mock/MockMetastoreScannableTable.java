package org.apache.bookkeeper.metastore.mock;

import java.util.Iterator;
import java.util.Map;
import java.util.NavigableMap;
import java.util.Vector;

import org.apache.bookkeeper.metastore.*;

import org.apache.bookkeeper.metastore.SimpleScanResult;

/**
 * MockMetadataScannableTable implements a table with auto-inc key generation and scan.
 * @author rbush
 * A scannable table can easily be implemented by a native metadata store that has
 * infinitely growable tables in a flat, semi-ordered space.  The calls in this case
 * are generally simple pass-through to the store native calls.
 * 
 * For a hierarchical store, such as ZooKeeper, we can implement this table and provide
 * a flat, semi-ordered space using a simple key transformation.  We use the same
 * trick that the HierarchicalManagedLedger uses.  That is, an integer key is transformed to
 * auto-generate partitions, which zk.getChildren can fetch in one call, successfully).
 * 
 * This demo performs a simple key transformation, which is not necessary for this class
 * per se, but shows potential work required for the ZooKeeper implementation of
 * a MetadataScannableTable.
 */
public class MockMetastoreScannableTable extends MockMetastoreTable implements MetastoreScannableTable {
	
	private long counter = 1;
	final String prefix = "/partition/";
	final int prefixLength = prefix.length ();
	
	public MockMetastoreScannableTable (MockMetastorePlugin plugin, String name) {
		super (plugin, name);
	}
	
	private String transformInKey (String externalKey) {
		return prefix + externalKey;
	}
	
	private String transformOutKey (String internalKey) {
		int x = internalKey.indexOf (prefix);
		if (x < 0)
			return null;
		return internalKey.substring (prefixLength);
	}
	
	public void generateUniqueNumericKey(MetastoreCallback<String> cb) {
		String autoGeneratedKey = Long.toString (counter++);
		int rc = 0;
		cb.complete (rc, null, autoGeneratedKey);
	}

	
	public void addRecord (MetastoreCallback<String> cb, String value) {
		String autoGeneratedKey = mockAddRecord (value);
		int rc = 0;
		cb.complete (rc, null, autoGeneratedKey);
	}
	
	public void scan(MetastoreCallback<ScanResult> cb, String firstKey, String lastKey) {
		ScanResult result = mockScan (firstKey, lastKey);
		int rc = 0;
		cb.complete (rc, null, result);
	}
	
	public void get (MetastoreCallback<String> cb, String key) {
		super.get (cb, transformInKey (key));
	}
	
	public void put (MetastoreCallback<String> cb, String key, String value) {
		super.put (cb, transformInKey (key), value);
	}
	
	public void remove (MetastoreCallback<String> cb, String key) {
		super.remove(cb, transformInKey (key));
	}
	
	public void compareAndPut (MetastoreCallback<Boolean> cb, String key, String oldValue, String newValue) {
		super.compareAndPut (cb, transformInKey (key), oldValue, newValue);
	}
	
	

	private String mockAddRecord (String value) {	
		String key = Long.toString (counter++);
		map.put (transformInKey (key), value);
		return key;
	}

	private ScanResult mockScan (String firstKey, String lastKey) {
		
		// Nulls are allowed
		
		String effectiveFirstKey = firstKey == null ?
				map.firstKey () : transformInKey (firstKey);
		String effectiveLastKey = lastKey == null ?
				map.lastKey () : transformInKey(lastKey);

		Vector<MetastoreTableItem> vector = new Vector<MetastoreTableItem>();
		
		NavigableMap<String, String> tempMap = map.tailMap (effectiveFirstKey, true);
		Iterator<Map.Entry<String, String>> iter = tempMap.entrySet ().iterator ();

		boolean foundLast = false;
		while ( ! foundLast && iter.hasNext ()) {
			Map.Entry<String, String> entry = iter.next ();
			String v = entry.getValue ();
			String currentKey = entry.getKey ();
			foundLast = currentKey.equals(effectiveLastKey);
			
			// If the passed in lastKey was null, we need to include the
			// effectiveLastKey in the returned set (otherwise omit it as
			// it was specified).  Scan ranges are "closed on the left and
			// open on the right".
			
			if (foundLast && lastKey != null)
				break;
			
			vector.add (new MetastoreTableItem (transformOutKey (currentKey), v));
		}
		
		return new SimpleScanResult(getPlugin(), vector.iterator());
	}

}
